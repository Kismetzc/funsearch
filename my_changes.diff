diff --git a/implementation/programs_database.py b/implementation/programs_database.py
index e8e4ba3..b9df366 100644
--- a/implementation/programs_database.py
+++ b/implementation/programs_database.py
@@ -134,6 +134,26 @@ class ProgramsDatabase:
             self._best_score_per_island[island_id] = score
             logging.info('Best score of island %d increased to %s', island_id, score)
 
+        # --- 在这里加入检查和醒目打印 ---
+        best_fit_score_baseline = -212.0000000001 # 设置一个略高于 BF 的阈值，避免浮点数精度问题
+        current_best_score_on_island = self._best_score_per_island[island_id]
+
+        if score > self._best_score_per_island[island_id]:
+            self._best_program_per_island[island_id] = program
+            self._best_scores_per_test_per_island[island_id] = scores_per_test
+            self._best_score_per_island[island_id] = score
+            logging.info('Best score of island %d increased to %s', island_id, score)
+
+            # --- 关键的检查和打印逻辑 ---
+            if score > best_fit_score_baseline and current_best_score_on_island <= best_fit_score_baseline:
+                 # 只有当新分数 > BF 且之前的最佳分数 <= BF 时才打印（确保只在第一次突破时打印）
+                 print("\n" + "*"*20 + " BREAKTHROUGH ALERT " + "*"*20)
+                 print(f"Island {island_id}: Found new best score {score:.6f}, surpassing Best Fit ({best_fit_score_baseline:.6f})!")
+                 print(f"Sample Order: {kwargs.get('global_sample_nums', 'N/A')}")
+                 print("See registered function details above/below this message.")
+                 print("*"*62 + "\n")
+            # --- 结束关键逻辑 ---
+
         # ======== RZ: profiling ========
         profiler: profile.Profiler = kwargs.get('profiler', None)
         if profiler:
@@ -144,7 +164,7 @@ class ProgramsDatabase:
             program.global_sample_nums = global_sample_nums
             program.sample_time = sample_time
             program.evaluate_time = evaluate_time
-            profiler.register_function(program)
+            profiler.register_function(program) # Profiler 会打印函数的详细信息
 
     def register_program(
             self,
@@ -261,37 +281,108 @@ class Island:
     def _generate_prompt(
             self,
             implementations: Sequence[code_manipulation.Function]) -> str:
-        """Creates a prompt containing a sequence of function `implementations`."""
-        implementations = copy.deepcopy(implementations)  # We will mutate these.
+        """创建一个包含适当结构和指导的提示。"""
+        implementations = copy.deepcopy(implementations)  # 我们将修改这些实现
 
-        # Format the names and docstrings of functions to be included in the prompt.
+        # 格式化要包含在提示中的函数的名称和文档字符串
         versioned_functions: list[code_manipulation.Function] = []
         for i, implementation in enumerate(implementations):
             new_function_name = f'{self._function_to_evolve}_v{i}'
             implementation.name = new_function_name
-            # Update the docstring for all subsequent functions after `_v0`.
+            # 更新`_v0`之后的所有后续函数的文档字符串
             if i >= 1:
                 implementation.docstring = (
                     f'Improved version of `{self._function_to_evolve}_v{i - 1}`.')
-            # If the function is recursive, replace calls to itself with its new name.
+            # 如果函数是递归的，将对自身的调用替换为其新名称
             implementation = code_manipulation.rename_function_calls(
                 str(implementation), self._function_to_evolve, new_function_name)
             versioned_functions.append(
                 code_manipulation.text_to_function(implementation))
 
-        # Create the header of the function to be generated by the LLM.
+        # 添加一个额外的"演示版本" (仅适用于priority函数)
+        # 检查是否是处理priority函数
+        if self._function_to_evolve == "priority" and len(implementations) > 0:
+            try:
+                # 使用小数版本号，避免与真实版本冲突
+                demo_version = len(implementations) - 0.5
+                demo_name = f'{self._function_to_evolve}_v{demo_version}'
+                
+                # 创建演示函数
+                demo_function = code_manipulation.Function(
+                    name=demo_name,
+                    params=implementations[-1].params,  # 使用相同参数
+                    body="""    # DEMONSTRATION: This shows correct structure with proper error handling
+        try:
+            # 1. Input validation and conversion
+            if not isinstance(bins, np.ndarray):
+                bins = np.array(bins, dtype=float)
+                
+            # 2. Calculate scores using a strategy better than Best-Fit
+            # This is just an example - create your own smart strategy
+            remaining_space = bins - item
+            bin_capacity = np.max(bins) + item  # Estimate original capacity
+            fullness_ratio = 1 - (remaining_space / bin_capacity)
+            
+            # Apply weight to remaining space based on bin fullness
+            # Higher score = better choice
+            scores = fullness_ratio * 10 - remaining_space
+            
+            # 3. Handle edge cases and ensure clean return
+            # Replace any NaN/inf with very negative value
+            return np.nan_to_num(scores, nan=-1e9, posinf=-1e9, neginf=-1e9)
+        except Exception as e:
+            # Always include this safe fallback
+            return np.full_like(bins, -1e9) if isinstance(bins, np.ndarray) else np.array([], dtype=float)
+        """,
+                    docstring="Demonstration of correct code structure with advanced bin packing strategy.",
+                    return_type=implementations[-1].return_type if hasattr(implementations[-1], 'return_type') else None,
+                )
+                
+                # 插入演示函数到版本列表 (在最后一个函数之前)
+                versioned_functions.append(demo_function)
+            except Exception as e:
+                # 如果添加演示代码失败，记录错误但继续
+                logging.warning(f"Failed to add demonstration code: {e}")
+                # 不要中断正常流程，继续执行
+
+        # 创建由LLM生成的函数的头部
         next_version = len(implementations)
         new_function_name = f'{self._function_to_evolve}_v{next_version}'
+        
+        # 针对priority函数添加特殊的文档字符串和指导
+        if self._function_to_evolve == "priority":
+            header_docstring = (
+                'Improved version of '
+                f'`{self._function_to_evolve}_v{next_version - 1}`.\n\n'
+                'REQUIREMENTS:\n'
+                '1. Must return a numpy array with SAME SHAPE as `bins`\n'
+                '2. Always wrap code in try-except as shown in examples\n'
+                '3. Never return None\n'
+                '4. Handle non-numpy input properly\n\n'
+                'USE THIS STRUCTURE:\n'
+                'def priority(item, bins):\n'
+                '    try:\n'
+                '        # YOUR IMPROVED ALGORITHM HERE\n'
+                '        return scores # Must be numpy array with same shape as bins\n'
+                '    except Exception as e:\n'
+                '        return np.full_like(bins, -1e9) if isinstance(bins, np.ndarray) else np.array([], dtype=float)'
+            )
+        else:
+            # 对于非priority函数，使用默认文档字符串
+            header_docstring = (
+                'Improved version of '
+                f'`{self._function_to_evolve}_v{next_version - 1}`.'
+            )
+        
         header = dataclasses.replace(
             implementations[-1],
             name=new_function_name,
             body='',
-            docstring=('Improved version of '
-                       f'`{self._function_to_evolve}_v{next_version - 1}`.'),
+            docstring=header_docstring,
         )
         versioned_functions.append(header)
 
-        # Replace functions in the template with the list constructed here.
+        # 用这里构造的列表替换模板中的函数
         prompt = dataclasses.replace(self._template, functions=versioned_functions)
         return str(prompt)
 
